// src/utils.ts
import naturalCompare from "natural-compare";
function isUnsorted(nodes, sorted) {
  return nodes.find((node, i) => node !== sorted[i]);
}
function enumerate(a, b) {
  return a.map((val, index2) => [val, b[index2]]).filter((x) => x[0] !== x[1]);
}
function getName(node) {
  switch (node?.type) {
    case "Identifier":
    case "PrivateIdentifier":
      return node.name;
    case "Literal":
      return node.value.toString();
    case "TemplateLiteral":
      return node.quasis.reduce(
        (acc, quasi, i) => acc + quasi.value.raw + getName(node.expressions[i]),
        ""
      );
  }
  return "";
}
var filterNodes = (nodes, types) => nodes.filter(
  (node) => types.includes(node.type)
);
var getSorter = ({
  caseSensitive = false,
  natural = true
} = {}) => {
  if (caseSensitive && natural) {
    return (a, b) => naturalCompare(a, b);
  } else if (caseSensitive) {
    return (a, b) => a < b ? -1 : a > b ? 1 : 0;
  } else if (natural) {
    return (a, b) => naturalCompare(a.toLowerCase(), b.toLowerCase());
  }
  return (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
};
var getTextRange = (left, right) => [
  range.start(left),
  range.end(right)
];
function getNodeRange(source, node, includeComments = true) {
  return getTextRange(
    includeComments && source.getCommentsBefore(node)[0] || node,
    node
  );
}
function getNodeText(source, node, includeComments = true) {
  return source.getText().slice(...getNodeRange(source, node, includeComments));
}
var docsURL = (ruleName) => `https://github.com/mskelton/eslint-plugin-sort/blob/main/docs/rules/${ruleName}.md`;
function report(context, nodes, sorted) {
  const source = context.getSourceCode();
  const firstUnsortedNode = isUnsorted(nodes, sorted);
  if (firstUnsortedNode) {
    context.report({
      node: firstUnsortedNode,
      messageId: "unsorted",
      *fix(fixer) {
        for (const [node, complement] of enumerate(nodes, sorted)) {
          yield fixer.replaceTextRange(
            getNodeRange(source, node),
            getNodeText(source, complement)
          );
        }
      }
    });
  }
}
var range = {
  start: (node) => node.range[0],
  end: (node) => node.range[1]
};
var pluralize = (word, count) => word + (count === 1 ? "" : "s");
function getImportOrExportKindWeight(typeOrder, kind) {
  if (typeOrder === "first") {
    return kind === "type" ? -1 : 1;
  }
  if (typeOrder === "last") {
    return kind === "type" ? 1 : -1;
  }
  return 0;
}

// src/rules/destructuring-properties.ts
var destructuring_properties_default = {
  create(context) {
    const options = context.options[0];
    const sorter = getSorter(options);
    return {
      ObjectPattern(pattern) {
        const nodes = filterNodes(pattern.properties, ["Property"]);
        if (nodes.length < 2) {
          return;
        }
        const sorted = nodes.slice().sort(
          (nodeA, nodeB) => sorter(getName(nodeA.key), getName(nodeB.key))
        );
        report(context, nodes, sorted);
      }
    };
  },
  meta: {
    docs: {
      url: docsURL("destructuring-properties")
    },
    fixable: "code",
    messages: {
      unsorted: "Destructuring properties should be sorted alphabetically."
    },
    schema: [
      {
        additionalProperties: false,
        default: { caseSensitive: false, natural: true },
        properties: {
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        },
        type: "object"
      }
    ],
    type: "suggestion"
  }
};

// src/resolver.ts
import resolve from "isomorphic-resolve";
var resolveCache = /* @__PURE__ */ new Map();
function isResolved(source) {
  if (globalThis.resolver) {
    return globalThis.resolver(source);
  }
  if (resolveCache.has(source)) {
    return resolveCache.get(source);
  }
  try {
    resolve(source);
    resolveCache.set(source, true);
    return true;
  } catch (e) {
    resolveCache.set(source, false);
    return false;
  }
}

// src/rules/exports.ts
var sortGroupsTypes = [
  "default",
  "sourceless",
  "dependency",
  "type",
  "other"
];
function getSortGroup(sortGroups, node) {
  const source = getSortValue(node);
  const isDefaultExport = node.type === "ExportDefaultDeclaration";
  for (const { regex, type, order } of sortGroups) {
    switch (type) {
      case "default":
        if (isDefaultExport)
          return order;
        break;
      case "sourceless":
        if (!isDefaultExport && !node.source)
          return order;
        break;
      case "type": {
        const { exportKind } = node;
        if (exportKind === "type")
          return order;
        break;
      }
      case "dependency":
        if (isResolved(source))
          return order;
        break;
      case "other":
        return order;
    }
    if (regex && new RegExp(regex).test(source)) {
      return order;
    }
  }
  return 0;
}
function getExportKindWeight(options, node) {
  const typeOrder = options?.typeOrder ?? "preserve";
  const kind = node.exportKind;
  return getImportOrExportKindWeight(typeOrder, kind);
}
function getSortValue(node) {
  return node.type !== "ExportDefaultDeclaration" && node.source ? getName(node.source) : "";
}
var exports_default = {
  create(context) {
    const options = context.options[0];
    const groups = options?.groups ?? [];
    const sorter = getSorter(options);
    return {
      Program(program) {
        const nodes = filterNodes(program.body, [
          "ExportNamedDeclaration",
          "ExportAllDeclaration",
          "ExportDefaultDeclaration"
        ]);
        if (nodes.length < 2) {
          return;
        }
        const sorted = nodes.slice().sort(
          (a, b) => (
            // First sort by sort group
            getSortGroup(groups, a) - getSortGroup(groups, b) || // Then sort by export name
            sorter(getSortValue(a), getSortValue(b)) || // Finally sort by export kind
            getExportKindWeight(options, a) - getExportKindWeight(options, b)
          )
        );
        report(context, nodes, sorted);
      }
    };
  },
  meta: {
    type: "suggestion",
    fixable: "code",
    docs: {
      url: docsURL("exports")
    },
    messages: {
      unsorted: "Exports should be sorted alphabetically."
    },
    schema: [
      {
        type: "object",
        properties: {
          groups: {
            type: "array",
            items: {
              type: "object",
              properties: {
                type: {
                  enum: sortGroupsTypes
                },
                regex: {
                  type: "string"
                },
                order: {
                  type: "number"
                }
              },
              required: ["order"],
              additionalProperties: false
            }
          },
          typeOrder: {
            enum: ["preserve", "first", "last"],
            default: "preserve"
          },
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        }
      }
    ]
  }
};

// src/rules/export-members.ts
var export_members_default = {
  create(context) {
    const options = context.options[0];
    const sorter = getSorter(options);
    return {
      ExportNamedDeclaration({ specifiers: nodes }) {
        if (nodes.length < 2) {
          return;
        }
        const sorted = nodes.slice().sort((nodeA, nodeB) => sorter(nodeA.local.name, nodeB.local.name));
        report(context, nodes, sorted);
      }
    };
  },
  meta: {
    docs: {
      url: docsURL("export-members")
    },
    fixable: "code",
    messages: {
      unsorted: "Export members should be sorted alphabetically."
    },
    schema: [
      {
        additionalProperties: false,
        default: { caseSensitive: false, natural: true },
        properties: {
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        },
        type: "object"
      }
    ],
    type: "suggestion"
  }
};

// src/rules/imports.ts
var sortGroupsTypes2 = ["side-effect", "dependency", "type", "other"];
function getSortGroup2(sortGroups, node) {
  const source = getName(node.source);
  for (const { regex, type, order } of sortGroups) {
    switch (type) {
      case "side-effect":
        if (!node.specifiers.length)
          return order;
        break;
      case "type": {
        const { importKind } = node;
        if (importKind === "type")
          return order;
        break;
      }
      case "dependency":
        if (isResolved(source))
          return order;
        break;
      case "other":
        return order;
    }
    if (regex && new RegExp(regex).test(source)) {
      return order;
    }
  }
  return 0;
}
function getImportKindWeight(options, node) {
  const typeOrder = options?.typeOrder ?? "preserve";
  const kind = node.importKind;
  return getImportOrExportKindWeight(typeOrder, kind);
}
var getSortValue2 = (node) => getName(node.source);
var rawString = (str) => JSON.stringify(str).slice(1, -1).replace(/\\n/g, "\\n");
var imports_default = {
  create(context) {
    const options = context.options[0];
    const groups = options?.groups ?? [];
    const separator = options?.separator ?? "";
    const sorter = getSorter(options);
    const source = context.getSourceCode();
    return {
      Program(program) {
        const nodes = filterNodes(program.body, ["ImportDeclaration"]);
        if (nodes.length < 2) {
          return;
        }
        const sorted = nodes.slice().sort(
          (a, b) => (
            // First sort by sort group
            getSortGroup2(groups, a) - getSortGroup2(groups, b) || // Then sort by import name
            sorter(getSortValue2(a), getSortValue2(b)) || // Finally sort by import kind
            getImportKindWeight(options, a) - getImportKindWeight(options, b)
          )
        );
        const firstUnsortedNode = isUnsorted(nodes, sorted);
        if (firstUnsortedNode) {
          const isFirst = (node) => node === nodes[0];
          context.report({
            node: firstUnsortedNode,
            messageId: "unsorted",
            *fix(fixer) {
              for (const [node, complement] of enumerate(nodes, sorted)) {
                yield fixer.replaceTextRange(
                  getNodeRange(source, node, !isFirst(node)),
                  getNodeText(source, complement, !isFirst(complement))
                );
              }
            }
          });
        }
        const text = source.getText();
        for (let i = 1; i < nodes.length; i++) {
          const node = nodes[i];
          const prevNode = nodes[i - 1];
          const nodeOrComment = source.getCommentsBefore(node)[0] ?? node;
          const rangeBetween = [
            range.end(prevNode),
            range.start(nodeOrComment)
          ];
          const actualSeparator = text.slice(...rangeBetween).replace(/[^\n]/g, "").replace("\n", "");
          const startLine = (prevNode.loc?.end.line ?? 0) + 1;
          const endLine = (nodeOrComment.loc?.start.line ?? 0) - 1;
          const loc = {
            start: { line: startLine, column: 0 },
            end: { line: Math.max(endLine, startLine), column: 0 }
          };
          const isSameGroup = getSortGroup2(groups, sorted[i - 1]) === getSortGroup2(groups, sorted[i]);
          if (isSameGroup || separator === "") {
            if (actualSeparator !== "") {
              context.report({
                messageId: "extraNewlines",
                loc,
                data: {
                  newlines: pluralize("newline", actualSeparator.length)
                },
                fix: (fixer) => fixer.replaceTextRange(rangeBetween, "\n")
              });
            }
          } else if (separator !== "" && actualSeparator === "") {
            context.report({
              messageId: "missingSeparator",
              loc,
              data: { expected: rawString(separator) },
              fix: (fixer) => fixer.insertTextAfter(prevNode, separator)
            });
          } else if (separator !== actualSeparator) {
            context.report({
              messageId: "incorrectSeparator",
              loc,
              data: {
                actual: rawString(actualSeparator),
                expected: rawString(separator)
              },
              fix: (fixer) => fixer.replaceTextRange(rangeBetween, separator + "\n")
            });
          }
        }
      }
    };
  },
  meta: {
    fixable: "code",
    type: "suggestion",
    docs: {
      url: docsURL("imports")
    },
    messages: {
      incorrectSeparator: "Expected `{{expected}}` to separate import groups but found `{{actual}}`.",
      extraNewlines: "Unexpected {{newlines}} between imports.",
      missingSeparator: "Missing `{{expected}}` between import groups.",
      unsorted: "Imports should be sorted."
    },
    schema: [
      {
        type: "object",
        properties: {
          groups: {
            type: "array",
            items: {
              type: "object",
              properties: {
                type: {
                  enum: sortGroupsTypes2
                },
                regex: {
                  type: "string"
                },
                order: {
                  type: "number"
                }
              },
              required: ["order"],
              additionalProperties: false
            }
          },
          separator: {
            type: "string",
            default: ""
          },
          typeOrder: {
            enum: ["preserve", "first", "last"],
            default: "preserve"
          },
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        }
      }
    ]
  }
};

// src/rules/import-members.ts
var import_members_default = {
  create(context) {
    const options = context.options[0];
    const sorter = getSorter(options);
    return {
      ImportDeclaration(decl) {
        const nodes = filterNodes(decl.specifiers, ["ImportSpecifier"]);
        if (nodes.length < 2) {
          return;
        }
        const sorted = nodes.slice().sort(
          (nodeA, nodeB) => sorter(nodeA.imported.name, nodeB.imported.name)
        );
        report(context, nodes, sorted);
      }
    };
  },
  meta: {
    docs: {
      url: docsURL("import-members")
    },
    fixable: "code",
    messages: {
      unsorted: "Import members should be sorted alphabetically."
    },
    schema: [
      {
        additionalProperties: false,
        default: { caseSensitive: false, natural: true },
        properties: {
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        },
        type: "object"
      }
    ],
    type: "suggestion"
  }
};

// src/rules/object-properties.ts
function groupNodes(properties) {
  const groups = [[]];
  properties.forEach((property) => {
    if (property.type === "Property") {
      groups[groups.length - 1].push(property);
    } else {
      groups.push([]);
    }
  });
  return groups.filter((group) => group.length > 1);
}
var object_properties_default = {
  create(context) {
    const options = context.options[0];
    const sorter = getSorter(options);
    return {
      ObjectExpression(expression) {
        for (const nodes of groupNodes(expression.properties)) {
          const sorted = nodes.slice().sort(
            (nodeA, nodeB) => sorter(getName(nodeA.key), getName(nodeB.key))
          );
          report(context, nodes, sorted);
        }
      }
    };
  },
  meta: {
    docs: {
      url: docsURL("object-properties")
    },
    fixable: "code",
    messages: {
      unsorted: "Object properties should be sorted alphabetically."
    },
    schema: [
      {
        additionalProperties: false,
        default: { caseSensitive: false, natural: true },
        properties: {
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        },
        type: "object"
      }
    ],
    type: "suggestion"
  }
};

// src/rules/type-properties.ts
import {
  AST_NODE_TYPES as AST_NODE_TYPES2,
  ESLintUtils
} from "@typescript-eslint/experimental-utils";

// src/ts-utils.ts
import {
  AST_NODE_TYPES
} from "@typescript-eslint/experimental-utils";
function getName2(node) {
  switch (node?.type) {
    case AST_NODE_TYPES.Identifier:
      return node.name;
    case AST_NODE_TYPES.Literal:
      return node.value.toString();
    case AST_NODE_TYPES.TemplateLiteral:
      return node.quasis.reduce(
        (acc, quasi, i) => acc + quasi.value.raw + getName2(node.expressions[i]),
        ""
      );
  }
  return "";
}
function getNodeRange2(source, node) {
  return getTextRange(source.getCommentsBefore(node)[0] ?? node, node);
}
function getNodeText2(source, node) {
  return source.getText().slice(...getNodeRange2(source, node));
}
var isDelimiter = (token) => token?.type === "Punctuator" && (token.value === "," || token.value === ";");

// src/rules/type-properties.ts
function getWeight(node) {
  const weights = {
    [AST_NODE_TYPES2.TSConstructSignatureDeclaration]: 0,
    [AST_NODE_TYPES2.TSCallSignatureDeclaration]: 1,
    [AST_NODE_TYPES2.TSPropertySignature]: 2,
    [AST_NODE_TYPES2.TSMethodSignature]: 2,
    [AST_NODE_TYPES2.TSIndexSignature]: 3
  };
  return weights[node.type];
}
function getSortValue3(node) {
  switch (node.type) {
    case AST_NODE_TYPES2.TSPropertySignature:
    case AST_NODE_TYPES2.TSMethodSignature:
      return getName2(node.key);
    case AST_NODE_TYPES2.TSIndexSignature:
      return getName2(node.parameters[0]);
  }
  return "";
}
var type_properties_default = ESLintUtils.RuleCreator.withoutDocs({
  create(context) {
    const source = context.getSourceCode();
    const options = context.options[0];
    const sorter = getSorter(options);
    function getRangeWithoutDelimiter(node) {
      const range2 = getNodeRange2(source, node);
      return isDelimiter(source.getLastToken(node)) ? [range2[0], range2[1] - 1] : range2;
    }
    function sort(nodes) {
      if (nodes.length < 2) {
        return;
      }
      const sorted = nodes.slice().sort(
        (a, b) => (
          // First sort by weight
          getWeight(a) - getWeight(b) || // Then sort by name
          sorter(getSortValue3(a), getSortValue3(b))
        )
      );
      const firstUnsortedNode = isUnsorted(nodes, sorted);
      if (firstUnsortedNode) {
        context.report({
          node: firstUnsortedNode,
          messageId: "unsorted",
          *fix(fixer) {
            for (const [node, complement] of enumerate(nodes, sorted)) {
              yield fixer.replaceTextRange(
                getRangeWithoutDelimiter(node),
                getNodeText2(source, complement).replace(/[;,]$/, "")
              );
            }
          }
        });
      }
    }
    return {
      TSInterfaceBody(node) {
        sort(node.body);
      },
      TSTypeLiteral(node) {
        sort(node.members);
      }
    };
  },
  meta: {
    docs: {
      recommended: false,
      url: docsURL("type-properties"),
      description: `Sorts TypeScript type properties alphabetically and case insensitive in ascending order.`
    },
    fixable: "code",
    messages: {
      unsorted: "Type properties should be sorted alphabetically."
    },
    schema: [
      {
        additionalProperties: false,
        default: { caseSensitive: false, natural: true },
        properties: {
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        },
        type: "object"
      }
    ],
    type: "suggestion"
  },
  defaultOptions: [{}]
});

// src/rules/string-unions.ts
import {
  ESLintUtils as ESLintUtils2,
  TSESTree as TSESTree3
} from "@typescript-eslint/experimental-utils";
function getSortValue4(node) {
  return node.type === TSESTree3.AST_NODE_TYPES.TSLiteralType && node.literal.type === TSESTree3.AST_NODE_TYPES.Literal && typeof node.literal.value === "string" ? node.literal.value : null;
}
var string_unions_default = ESLintUtils2.RuleCreator.withoutDocs({
  create(context) {
    const source = context.getSourceCode();
    const options = context.options[0];
    const sorter = getSorter(options);
    return {
      TSUnionType(node) {
        const nodes = node.types;
        if (nodes.length < 2)
          return;
        if (nodes.map(getSortValue4).some((value) => value === null))
          return;
        const sorted = nodes.slice().sort((a, b) => sorter(getSortValue4(a) ?? "", getSortValue4(b) ?? ""));
        const firstUnsortedNode = isUnsorted(nodes, sorted);
        if (firstUnsortedNode) {
          context.report({
            node: firstUnsortedNode,
            messageId: "unsorted",
            *fix(fixer) {
              for (const [node2, complement] of enumerate(nodes, sorted)) {
                yield fixer.replaceText(node2, getNodeText2(source, complement));
              }
            }
          });
        }
      }
    };
  },
  meta: {
    docs: {
      recommended: false,
      url: docsURL("string-unions"),
      description: `Sorts TypeScript string unions alphabetically and case insensitive in ascending order.`
    },
    fixable: "code",
    messages: {
      unsorted: "String unions should be sorted alphabetically."
    },
    schema: [
      {
        additionalProperties: false,
        default: { caseSensitive: false, natural: true },
        properties: {
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        },
        type: "object"
      }
    ],
    type: "suggestion"
  },
  defaultOptions: [{}]
});

// src/rules/string-enums.ts
import {
  ESLintUtils as ESLintUtils3,
  TSESTree as TSESTree4
} from "@typescript-eslint/experimental-utils";
function getSortValue5(node) {
  return node.initializer?.type === TSESTree4.AST_NODE_TYPES.Literal && typeof node.initializer.value === "string" ? node.initializer.value : null;
}
var string_enums_default = ESLintUtils3.RuleCreator.withoutDocs({
  create(context) {
    const source = context.getSourceCode();
    const options = context.options[0];
    const sorter = getSorter(options);
    return {
      TSEnumDeclaration(node) {
        const nodes = node.members;
        if (nodes.length < 2)
          return;
        if (nodes.map(getSortValue5).some((value) => value === null))
          return;
        const sorted = nodes.slice().sort((a, b) => sorter(getSortValue5(a) ?? "", getSortValue5(b) ?? ""));
        const firstUnsortedNode = isUnsorted(nodes, sorted);
        if (firstUnsortedNode) {
          context.report({
            node: firstUnsortedNode,
            messageId: "unsorted",
            *fix(fixer) {
              for (const [node2, complement] of enumerate(nodes, sorted)) {
                yield fixer.replaceText(node2, getNodeText2(source, complement));
              }
            }
          });
        }
      }
    };
  },
  meta: {
    docs: {
      recommended: false,
      url: docsURL("string-enums"),
      description: `Sorts TypeScript string enums alphabetically and case insensitive in ascending order.`
    },
    fixable: "code",
    messages: {
      unsorted: "String enums should be sorted alphabetically."
    },
    schema: [
      {
        additionalProperties: false,
        default: { caseSensitive: false, natural: true },
        properties: {
          caseSensitive: {
            type: "boolean",
            default: false
          },
          natural: {
            type: "boolean",
            default: true
          }
        },
        type: "object"
      }
    ],
    type: "suggestion"
  },
  defaultOptions: [{}]
});

// src/index.ts
var index = {
  configs: {},
  rules: {
    "destructuring-properties": destructuring_properties_default,
    "exports": exports_default,
    "export-members": export_members_default,
    "imports": imports_default,
    "import-members": import_members_default,
    "object-properties": object_properties_default,
    "type-properties": type_properties_default,
    "string-unions": string_unions_default,
    "string-enums": string_enums_default
  }
};
var createConfig = (flat) => ({
  plugins: flat ? { sort: index } : ["sort"],
  rules: {
    "sort/destructuring-properties": "warn",
    "sort/exports": [
      "warn",
      {
        groups: [
          { type: "default", order: 50 },
          { type: "sourceless", order: 40 },
          { regex: "^\\.+\\/", order: 30 },
          { type: "dependency", order: 10 },
          { type: "other", order: 20 }
        ]
      }
    ],
    "sort/export-members": "warn",
    "sort/imports": [
      "warn",
      {
        groups: [
          { type: "side-effect", order: 10 },
          { regex: "^\\.+\\/", order: 40 },
          { type: "dependency", order: 20 },
          { type: "other", order: 30 }
        ]
      }
    ],
    "sort/import-members": "warn",
    "sort/object-properties": "warn"
  }
});
index.configs = {
  "recommended": createConfig(false),
  "flat/recommended": createConfig(true)
};
var src_default = index;
export {
  src_default as default
};
